# VEDA 미니프로젝트 2
## 개요
아래 조건을 만족하는 채팅 서버-클라이언트 구현
- 로그인 및 로그아웃 기능
- 데몬으로 실행되는 서버와 1:N 으로 연결되는 클라이언트
- 채팅 메시지와 유저 ID 가 함께 표시될 것

## 환경 및 제약조건
- 시스템 프로그래밍
- 리눅스 환경에서 개발
- cmake 를 활용한 빌드
- 멀티스레딩은 금지이며, 멀티프로세싱 활용
    - 프로세스간 통신(IPC)는 반드시 Pipe 만 허용

## 간단한 구조 설명
### 서버
    1. 서버는 부모 프로세스 하나와 N개의 자식 프로세스들로 구성된다.

    2. 부모 프로세스는 BSD 소켓과 accept 함수를 활용해 새 클라이언트와 연결한다.
    3. 또한, 부모 프로세스는 연결된 시점 직후 fork 함수로 자식 프로세스를 생성하고, 다시 accept 함수에서 연결을 기다린다.

    4. 자식 프로세스들은 클라이언트와의 연결 및 채팅을 1:1 로 관리한다.

### 클라이언트
    1. 각 클라이언트는 부모-자식 프로세스 각 1개로 구성된다.

    2. 부모 프로세스는 connect 함수를 활용해 실행 직후 서버와 연결한다.
    3. 연결 성공 후, 자식 프로세스를 생성하며 서버로부터 오는 채팅을 기다린다.

    4. 자식 프로세스는 사용자로부터의 키보드 입력을 기다리며, 입력이 오면 부모 프로세스에 전달한다.

## 시그널을 활용한 채팅 절차
    연결 완료 이후, 채팅이 진행되는 절차를 소개합니다.

### 1 단계 : 클라이언트에서 채팅 발송
    사용자가 채팅을 입력한 시점에, 클라이언트-부모 프로세스는 서버에서 오는 채팅을 read 함수로 기다리고 있다.
    이때, 클라이언트-자식 프로세스는 파이프로 키보드 입력 채팅을 write 함수로 보냄과 동시에, 시그널을 발생시켜 부모 프로세스가 비동기 처리를 하도록 트리거한다.

    클라이언트-부모 프로세스는 이 시그널 처리에서, 파이프를 통해 클라이언트-자식 프로세스가 보낸 키보드 입력 메시지를 받아 서버 소켓에 write 함수로 보낸 뒤 다시 본래 흐름으로 복귀한다.

### 2 단계 : 서버에서 채팅 수신 및 브로드캐스팅
    클라이언트-부모 프로세스로부터 채팅을 받은 서버-자식 프로세스는, 파이프에 채팅을 write 함수로 보냄과 동시에, 시그널을 발생시켜 부모 프로세스가 비동기 처리를 하도록 트리거한다.
    서버-부모 프로세스는 이 시그널 처리에서, 파이프를 통해 서버-자식 프로세스가 보낸 키보드 입력 메시지를 받아 브로드캐스팅하는데, 이때 전체 서버-자식 프로세스 목록을 순회하며 kill(pid,SIGUSR) 로 시그널을 발생시킴과 동시에, 파이프에 브로드캐스팅하고자 하는 채팅 메시지를 쓴다.
    서버-자식 프로세스는 이 시그널 처리에서 클라이언트-부모 프로세스가 관리하는 소켓에 채팅 메시지를 write 함수로 보낸다.

### 3 단계 : 클라이언트에서 채팅 수신 및 사용자에게 표시
    위의 브로드캐스팅 메시지를 받은 클라이언트-부모 프로세스는 클라이언트-자식 프로세스에 해당 메시지를 write 로 보내고, 시그널을 통해 비동기 처리를 트리거한다.
    해당 시그널 처리에서, 클라이언트-자식 프로세스는 사용자에게 해당 채팅 메시지를 UI 를 통해 만들어 보낸다.






